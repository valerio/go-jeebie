//go:build ignore
// +build ignore

package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
)

// Opcode represents a single Game Boy instruction
type Opcode struct {
	Mnemonic string   `json:"mnemonic"`
	Length   int      `json:"length"`
	Cycles   []int    `json:"cycles"`
	Flags    []string `json:"flags"`
	Addr     string   `json:"addr"`
	Group    string   `json:"group"`
	Operand1 string   `json:"operand1,omitempty"`
	Operand2 string   `json:"operand2,omitempty"`
}

// OpcodeSet contains both regular and CB-prefixed opcodes
type OpcodeSet struct {
	Unprefixed map[string]Opcode `json:"unprefixed"`
	CBPrefixed map[string]Opcode `json:"cbprefixed"`
}

func main() {
	fmt.Println("Generating Game Boy disassembly tables...")

	// Load opcodes JSON from local file
	opcodes, err := loadOpcodes()
	if err != nil {
		log.Fatalf("Failed to load opcodes: %v", err)
	}

	// Generate Go code
	err = generateCode(opcodes)
	if err != nil {
		log.Fatalf("Failed to generate code: %v", err)
	}

	fmt.Println("Successfully generated disassembly tables!")
}

func loadOpcodes() (*OpcodeSet, error) {
	// Load opcodes from local data file
	opcodeFile := "../../data/opcodes.json"

	fmt.Printf("Loading opcodes from %s...\n", opcodeFile)
	data, err := os.ReadFile(opcodeFile)
	if err != nil {
		return nil, fmt.Errorf("failed to read opcodes file: %w", err)
	}

	var opcodes OpcodeSet
	err = json.Unmarshal(data, &opcodes)
	if err != nil {
		return nil, fmt.Errorf("failed to parse JSON: %w", err)
	}

	return &opcodes, nil
}

func generateCode(opcodes *OpcodeSet) error {
	file, err := os.Create("generated.go")
	if err != nil {
		return fmt.Errorf("failed to create generated.go: %w", err)
	}
	defer file.Close()

	// Write file header
	fmt.Fprint(file, `// Code generated by go generate; DO NOT EDIT.

package disasm

// InstructionLengths contains the byte length of each main opcode
var InstructionLengths = [256]int{
`)

	// Generate instruction lengths array
	for i := 0; i < 256; i++ {
		addr := fmt.Sprintf("0x%02x", i) // Use lowercase hex to match JSON
		if opcode, exists := opcodes.Unprefixed[addr]; exists {
			fmt.Fprintf(file, "\t%d, // %s: %s\n", opcode.Length, addr, formatInstruction(opcode))
		} else {
			fmt.Fprintf(file, "\t1, // %s: UNDEFINED\n", addr)
		}
	}

	fmt.Fprint(file, `}

// InstructionTemplates contains format strings for each main opcode
var InstructionTemplates = [256]string{
`)

	// Generate instruction templates array
	for i := 0; i < 256; i++ {
		addr := fmt.Sprintf("0x%02x", i) // Use lowercase hex to match JSON
		if opcode, exists := opcodes.Unprefixed[addr]; exists {
			template := createTemplate(opcode)
			fmt.Fprintf(file, "\t%q, // %s\n", template, addr)
		} else {
			fmt.Fprintf(file, "\t\"UNDEFINED\", // %s\n", addr)
		}
	}

	fmt.Fprint(file, `}

// CBInstructionLengths contains the byte length of each CB-prefixed opcode
var CBInstructionLengths = [256]int{
`)

	// Generate CB instruction lengths
	for i := 0; i < 256; i++ {
		addr := fmt.Sprintf("0x%02x", i) // Use lowercase hex to match JSON
		if opcode, exists := opcodes.CBPrefixed[addr]; exists {
			// CB instructions are always 2 bytes total (CB prefix + opcode)
			fmt.Fprintf(file, "\t%d, // CB %s: %s\n", opcode.Length, addr, formatInstruction(opcode))
		} else {
			fmt.Fprintf(file, "\t2, // CB %s: UNDEFINED\n", addr)
		}
	}

	fmt.Fprint(file, `}

// CBInstructionTemplates contains format strings for each CB-prefixed opcode
var CBInstructionTemplates = [256]string{
`)

	// Generate CB instruction templates
	for i := 0; i < 256; i++ {
		addr := fmt.Sprintf("0x%02x", i) // Use lowercase hex to match JSON
		if opcode, exists := opcodes.CBPrefixed[addr]; exists {
			template := createTemplate(opcode)
			fmt.Fprintf(file, "\t%q, // CB %s\n", template, addr)
		} else {
			fmt.Fprintf(file, "\t\"UNDEFINED\", // CB %s\n", addr)
		}
	}

	fmt.Fprint(file, "}\n")

	return nil
}

func formatInstruction(opcode Opcode) string {
	instruction := opcode.Mnemonic
	if opcode.Operand1 != "" {
		instruction += " " + opcode.Operand1
		if opcode.Operand2 != "" {
			instruction += ", " + opcode.Operand2
		}
	}
	return instruction
}

func createTemplate(opcode Opcode) string {
	instruction := opcode.Mnemonic

	operands := []string{}
	if opcode.Operand1 != "" {
		operands = append(operands, formatOperand(opcode.Operand1))
	}
	if opcode.Operand2 != "" {
		operands = append(operands, formatOperand(opcode.Operand2))
	}

	if len(operands) > 0 {
		instruction += " " + strings.Join(operands, ", ")
	}

	return instruction
}

func formatOperand(operand string) string {
	switch operand {
	case "d16", "a16":
		return "0x%04X" // 16-bit value
	case "d8", "r8", "a8":
		return "0x%02X" // 8-bit value
	case "s8":
		return "%+d" // signed 8-bit value
	default:
		// Check if it's a numeric bit position
		if _, err := strconv.Atoi(operand); err == nil {
			return operand // Keep numeric values as-is
		}
		return operand // Register names, etc.
	}
}
